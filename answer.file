(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) How many major components of windows memory management are there     3
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "windows memory management" -What `segment` includes instructions that the CPU executes, & helps EIP keep track of the next instruction     code
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "windows memory management" -What `segment` includes variables, and dynamic buffers    data 
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "windows memory management" -What `segment` is used to pass data/arguments to functions, and is used as space for variables    the stack
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What starts from the very end of the virtual memory of a page and grows down to a lower address    the stack
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What adds something to the stack    PUSH
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What removes one item (4 bytes) from the stack & puts it in a register    POP
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What assembly register can be used to access the stack memory directly    ESP
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What are considered "special places" in memory where data can be stored (name, number, sentence)    Registers
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What is the acronym for ECX     extended counter register
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What is the acronym for EDX     extended data register
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What is the acronym for ESP     extended stack pointer
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What is the acronym for EBP     extended base pointer
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What is the acronym for ESI     extended source index
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What is the acronym for EDI     extended destination index
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What is the acronym for EIP     extended instruction pointer
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What is the acronym for EAX     extended accumulator register
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What is the acronym for EBX     extended base register
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) Which register is used for iterations & counts downward     ECX
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) Which register is an extension of EAX, & allows complex calculations like multiply/divide by allowing extra data to be stored to facilitate the calculations     EDX
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) Which register is the stack pointer     ESP
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) Which register is the Base Pointer     EBP
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) Which register is the source index, & holds location of input data     ESI
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) Which register is the destination index, & points to location where result data operation is stored     EDI
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) Which register is the instruction pointer     EIP
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What register is used as an accumulator for performing calculations, store function calls return values, as well as basic operations like add/subtract, & compare     EAX
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What register has no general purpose , & can be used to store data     EBX
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) How many bytes is 32 bits    4
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What is the smallest piece of data, & can also be either a 0 or a 1 (base 2 binary system)    bit
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) 8 BITS equal a    byte
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What numbering system uses base-16     hexadecimal
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) True/False : After a PUSH, ESP points to a lower memory address (address is decremented with the size of the data that is pushed onto the stack) which is 4 bytes     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) True/False : After a POP, ESP points to a higher address (address is incremented by 4 bytes). Increments happen after an item is removed from the stack     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process Memory" True/False : When an app is started in Win32, a process is started & virtual memory is assigned to it     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "32-bit Process Memory" True/False : The virtual memory address ranges from 0×00000000 to 0xFFFFFFFF is assigned to "user-land"     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "32-bit Process Memory" True/False : The virtual memory address ranges from 0×80000000 to 0xFFFFFFFF is assigned to "kernel-land"     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process Memory" True/False : Windows does not use the flat memory model, meaning the CPU can directly/sequentially/linearly address all of the available memory locations, without having to use a segmentation/paging scheme     False 
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process Memory" True/False : Kernel land memory is accessible to both the OS, & user     False
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process Memory" True/False : When a process is created, a PEB (Process Execution Block) & TEB (Thread Environment Block) are created     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process Memory" What is the acronym for PEB     Process Execution Block
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process Memory" What is the acronym for TEB     Thread Environment Block
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process Memory" What contains all user land parameters that are associated with the current process, EAX, TEB or PEB     PEB
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process Memory" True/False : The PEB shows the location of the main .exe, pointer to loader data (can be used to list all dll's/modules that are/can be loaded into the process), & pointer information about the heap     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process Memory" What describes the state of a thread, and includes location of the PEB in memory, location of the stack for the thread it belongs to, & pointer to the first entry in the SEH chain     TEB
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process memory" True/False : Each thread inside the process has one TEB     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process Memory" True/False : The "text segment" of a program image/.dll is readonly, as it only contains application code, preventing modification. This memory segment has a fixed size     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process Memory" True/False : What segment is writeable & has a fixed size     data
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "Process Memory" True/False : What segment is used for the rest of the program variables, can grow larger or smaller as desired, managed by allocator/de-allocator algorithms with reserved memory regions, & grow towards higher addresses     heap
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "The Stack" True/False : The Stack is a piece of the process memory, a data structure that works LIFO (Last in first out), & allocated by the OS for each thread when created, when the thread ends, the stack is cleared     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "The Stack" True/False : The size of the stack is defined when it gets created & doesn't change     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "The Stack" True/False : Combined with LIFO (Last in first out) and the fact that it does not require complex management structures/mechanisms to get managed, the stack is pretty fast, but limited in size     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "The Stack" True/False : LIFO means that the most recent placed data (result of a PUSH instruction) is the first one that will be removed from the stack again. (by a POP instruction)     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "The Stack" True/False : When a stack is created, the stack pointer points to the top of the stack ( = the highest address on the stack). As information is pushed onto the stack, this stack pointer decrements (goes to a lower address).  So in essence, the stack grows to a lower address     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "The Stack" True/False : The stack contains local variables, function calls and other info that does not need to be stored for a larger amount of time. As more data is added to the stack (pushed onto the stack), the stack pointer is decremented and points at a lower address value     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) "The Stack" True/False : Every time a function is called, the function parameters are pushed onto the stack, as well as the saved values of registers (EBP, EIP).  When a function returns, the saved value of EIP is retrieved from the stack and placed back in EIP, so the normal application flow can be resumed     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What does bit stand for     binary digit
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) What CPU Register are you trying so hard to overwrite     EIP
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) True/False : Its better to find a "jmp esp" address in the victim apps .dll rather than the OS .dll due to exploit portability     True
(Corelan exploit-writing-tutorial-part-1-stack-based-overflows) True/False : Every Windows application uses parts of memory. Three major components in process memory are code data & stack segments     True
(Corelan exploit writing tutorial part 2 : Stack Based Overflows – jumping to shellcode) True/False : There are multiple methods of forcing the execution of shellcode     Yes
(Corelan exploit writing tutorial part 2 : Stack Based Overflows – jumping to shellcode) Give an example of when you should use a different jmp technique     small buffer size
(Corelan exploit writing tutorial part 2 : Stack Based Overflows – jumping to shellcode) True/False : There are 4 common ways of forcing the execution of shellcode     False
(Corelan exploit writing tutorial part 2 : Stack Based Overflows – jumping to shellcode) True/False : There are 6 common ways of forcing the execution of shellcode     True
(Corelan exploit writing tutorial part 2 : Stack Based Overflows – jumping to shellcode) True/False : The 8 common ways of jmp'ing to shellcode are jump (or call), pop return, push return, jmp [reg + offset], blind return, SEH, popad, & hardcode address to jump to     True
(Corelan exploit writing tutorial part 2 : Stack Based Overflows – jumping to shellcode) Briefly describe the jump (or call) method     jmp esp opcode in vulnerable app
(Corelan exploit writing tutorial part 2 : Stack Based Overflows – jumping to shellcode) Briefly describe the pop return method     pop 4 bytes off the top of the stack
(Corelan exploit writing tutorial part 2 : Stack Based Overflows – jumping to shellcode) Briefly describe the push return method     find a push reg followed by a ret
(Corelan exploit writing tutorial part 2 : Stack Based Overflows – jumping to shellcode) Briefly describe the jmp [reg + offset] method     find an instruction in one of the OS or application dlls     
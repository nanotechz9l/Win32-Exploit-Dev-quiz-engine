#!/usr/bin/env ruby
#=================================================
#
# FILE: exploit_quiz.rb
#
#
# DESCRIPTION: Interactive quiz on Win32 Exploit Development Theory. 
# BUGS:    email me...
# NOTES:   Works on OpenBSD, freeBSD, Ubuntu, BT5 x64 with rainbow gem installed
# `Original Author` :  Steve PUGH - Wicked cool ruby scripts Chapter 5 pg.76
# `Code & Answer file` customizations, tweaks, & enhancements: Rick FLORES nanoquetz9l<@>nanotechfibers.com
# Answer file ref: @corelanc0d3r && https://www.corelan.be/index.php/category/security/exploit-writing-tutorials/
# I will be systematically && as time permits porting all tuts to ruby, and add them to the quiz engine for easier automation && memorization :)
# VERSION: 1.0
# CREATED: 07/11/11
# REVISION: 1.0
#
#  THIS FILE `exploit_quiz.rb` IS SUPPOSED TO BE RAN WITH THE SUPPLIED "answer.file " as an ARGV
#  like so ::: $ ./exploit_quiz.rb answer.file
#
#=================================================

begin
#require '/var/lib/gems/1.9.2/gems/rainbow-1.1.1/lib/rainbow.rb'
require 'rainbow'

rescue LoadError => e
puts "ERROR: Missing rainbow ruby gem. Install it by ::: sudo gem install rainbow."
puts e.inspect
end

=begin
Day 1 : Basics

    [~] x01, Windows Memory Management
    [~] x02, Using debuggers and debugger plugins to gather primitives
    [~] x03, Saved return pointer overwrites
    [~] x04, Stack cookies
    [~] x05, Abusing exception handler overwrites
    [~] x06, Bypassing SafeSEH
    [~] x07, Off-by-one and integer overflows
    [~] x08, Function pointer & Vtable overwrites
    [~] x09, Finding and avoiding bad characters / dealing with character set limitations
    [~] x10, Exploiting Unicode based overflows / writing venetian shellcode
    [~] x11, Heap Spraying

Day 2 : Advanced

    [~] x12, Using and tweaking Egg hunters / Omelet egghunters
    [~] x13, Using & writing shellcode
    [~] x14, Writing exploits for the Metasploit Framework
    [~] x15, Bypassing ASLR
    [~] x16, Bypassing NX/DEP (Return Oriented Programming / Code Reuse (ROP) )
=end

puts "\n\nWin32 Exploit Development Theory | an interactive memorization quiz engine v1.0".foreground(:red).bright 
puts "maintained/updated by Rick Flores (nanoquetz9l)".foreground(:green).bright
puts "Answer file ref: @corelanc0d3r && https://www.corelan.be/index.php/category/security/exploit-writing-tutorials/ \n\n\n".foreground(:green).bright

  #  ARGV[0] Allows command line arguments to be supplied at run time !
  #--------------------------------------------------
unless ARGV[0]
  puts "\nUsage is ./exploit_quiz.rb answer.file\n".foreground(:white).bright.blink
  exit
end
  
  # Script takes the flash card file and opens it for reading !
  #--------------------------------------------------
  flash = [] 
  
  # Using the Struct method to create a data structure named card !
  #--------------------------------------------------
  card = Struct.new( :question, :answer) 
 
  # Card contains two elements---question & answer. In order to make and collect all the questions/answers, the flash card input file is broken down line by line
  #--------------------------------------------------
  File.open(ARGV[0], "rb").each do |line|
    if line =~ /(.*)\s{3,10}(.*)/
      
      # Each question is added to an array called flash ! Once it reaches the end-of-file, the array has a complete collection of questions, & answers ! 
      flash << card.new($1.strip, $2.strip)  
    end
  end
  
  # In combination with the sort, & replace methods, rand makes asking the questions more random !
  flash.replace(flash.sort_by { rand })
  
  # The number of cards the array has will determine the number of asked questions !
  until flash.empty?
    drill = flash.pop
    
      # A random question is selected, .drill, & presented to the user !
      print "#{drill.question}? ".foreground(:white).bright
    guess = $stdin.gets.chomp
    
    # User input is read from the standard input at the console & compared to the answer in test bank!
    if guess.downcase == drill.answer.downcase
      puts "\nCorrect".foreground(:blue).bright.blink 
      puts "\n\nThe answer is #{drill.answer}\n\n\n".foreground(:blue).bright
    else
      puts "\n\nWRONG".foreground(:red).bright.blink 
      puts "\nThe answer is #{drill.answer}\n\n\n".foreground(:red).bright
    end
  end
